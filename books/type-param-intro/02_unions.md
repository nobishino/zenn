---
title: "unions"
---

# genericなMax関数とunions

標準パッケージの`math.Max`関数は`func Max(x, y float64) float64`というシグネチャを持ち、`float64`の値しか渡すことができません。

せっかく型パラメータが使えるようになるので、genericなMax関数を作ってみたいと思います。まず初めに次のようなコードを考えました。

```go
func Max(T any) (x, y T) T {
	if x >= y {
		return x
	}
	return y
}
```

ところが、このコードは動作せず、次のようなエラーメッセージを出力します。

```
invalid operation: cannot compare x >= y (operator >= not defined on T)
```

`T`の型制約は`any`なので、演算子`>=`で比較できるとは限らないからです。それでは、適当なインタフェース型を定義して演算子`>=`で比較できるような型制約にすることはできるでしょうか？

Go1.17までのインタフェース型では、これはできませんでした。なぜなら、Go1.17までのインタフェース型とは「メソッドセット」すなわちメソッドの集合（集まり）を定義するものであって、「ある演算子が使える」というようなメソッド以外の型の性質を表すことはできないからです。

そこでGo言語は、「インタフェース型」として次のようなものも定義できるように機能を拡張することにしました。

```go
type Number interface {
    int | int32 | int64 | float32 | float64
}
```

この`Number`というインタフェースは、`int, int32, int64, float32, float64`という5種類の型によって**「実装」**され、これ以外の型によっては実装されません。
この文法要素`int | int32 | int64 | float32 | float64`のことを`unions`や`union element`と呼びます。

:::message

`|`を使わずに一つだけの型を書けば、その**一つの型によってのみ実装されるインタフェース**を定義できます。

```go
type Int interface {
    int
}
```

この`Int`インタフェースを実装するのは`int`型のみです。

:::

大切なことは、`Number`を実装する全ての型は、演算子`>=`をサポートしていることです。これにより、次のような関数を書くことができます。

```go
type Number interface {
    int | int32 | int64 | float32 | float64
}

func Max[T Number] (x, y T) T {
	if x >= y {
		return x
	}
	return y
}
```

::: message

`>=`などで順序づけられる型はこの5つ以外にもありますが、全て書き出すと大変なため5つだけ書きました。
この辺りは後程触れる`constraints`パッケージで解決されます。

:::

# for~rangeが使えるインタフェース型

型の満たす性質にはいくつか種類があります。ここでいくつか挙げてみましょう。

- あるメソッドを持っているという性質
- `==, !=`で比較できるという性質
- `<, >, >=, <=`で順序づけられるという性質
- `for ~ range`文でループを回すことができるという性質
- ある名前のフィールドを持っているという性質
- etc

「あるメソッドを持っているという性質」は従来のインタフェース型で表現できます。
`==, !=`で比較可能な性質は、組み込みの`comparable`インタフェースで表現できるのでしたね。
そして`<, >`などで順序づけられる性質は`unions`を利用した新しいインタフェースで表現できることをみました。

次に、`for ~ range`でループを回せるという性質をみてみましょう。
面白みのない例ですが、次のコードはコンパイルできます。

https://gotipplay.golang.org/p/ec6KpsOHgHv

```go
type I interface {
	[]int 
}

func f[T I](x T) {
	for range x {
	}
}
```

`I`を実装する型は`[]int`のみで、かつこの型は`for range`でループすることができる型です。
このような場合、`I`を型制約とする型パラメータの値に対して`for range`ループを書くことができます。

::: message

ここで代わりに
```go
type I interface {
	[]int | []string
}
とするとコンパイルが通らなくなります。
```

> cannot range over x (variable of type T constrained by I) (T has no structural type)

ここで言われているのは`I`が"structral type"を持たないということです。この"structrual type"の説明は次章で行います。
:::


# `unions`を含むインタフェースは型制約でしか使えない

型制約ではなく通常の変数の型として`unions`を使うと、いわゆるsum typeのようなものが定義できそうに見えます。
しかし、現在のところこれは許可されません。

```go
type IntString interface {
	int | string
}

var x IntString // これはできない
```

この制限は将来的に取り除かれる可能性があります。型パラメータの導入だけでも非常に大きな変更であるため、安全を期するためにまずは最低限の機能でリリースし、実際の使われ方からフィードバックを得て判断していくのだと思います。

# フィールドを持つという性質は型制約で扱えない

できそうでできないことを1つ挙げておきます。ある名前のフィールドを持つという性質を型制約で表現することはできません。

https://gotipplay.golang.org/p/WEM-yelirK1

```go
type I interface {
	X
}

type X struct {
	SomeField int
}

func f[T I](x T) {
	fmt.Println(x.X) // これはできない
}
```

# まとめ

- Goの型パラメータは型制約をインタフェース型によって表現するが、型の性質には「メソッドを持つ」以外の性質もある。その性質の一部は`unions`を利用した新しいインタフェース型によって表現できる。
- `<, >, <=, >=`による順序付可能性は`unions`を使って順序づけられる型のみを列挙することで表現できる。
- `for range`ループができる型を使って、その1つの型だけからなる`unions`による型制約を作ると、その型制約に従う型パラメータ型の値について`for range`ループができる。
- `==, !=`による比較可能性は`comparable`インタフェースで表現する(再掲)。
- フィールドを持つという性質を型制約で表して、型パラメータ型の値のフィールドを参照することはできない。
