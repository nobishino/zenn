---
title: "Goè¨€èªã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å…¥é–€" # è¨˜äº‹ã®ã‚¿ã‚¤ãƒˆãƒ«
emoji: "ğŸ˜¸" # ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹çµµæ–‡å­—ï¼ˆ1æ–‡å­—ã ã‘ï¼‰
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢è¨˜äº‹
topics: ["go"] # ã‚¿ã‚°ã€‚["markdown", "rust", "aws"]ã®ã‚ˆã†ã«æŒ‡å®šã™ã‚‹
published: true # å…¬é–‹è¨­å®šï¼ˆfalseã«ã™ã‚‹ã¨ä¸‹æ›¸ãï¼‰
---

Go1.18ã¯2022å¹´3æœˆã«ãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã¾ã—ãŸã€‚ã“ã®ãƒªãƒªãƒ¼ã‚¹ã¯Goè¨€èªã¸ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®å®Ÿè£…ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚
ã“ã®è¨˜äº‹ã§ã¯ã§ãã‚‹ã ã‘æœ€æ–°ã®ä»•æ§˜ã¨ç”¨èªæ³•ã«ã‚‚ã¨ã¥ã„ã¦ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®è¨€èªä»•æ§˜ã«ã¤ã„ã¦è§£èª¬ã—ã¦ã„ãã¾ã™ã€‚

:::message
ã“ã®è¨˜äº‹ã®ã‚¿ã‚¤ãƒˆãƒ«ã¯æœ€åˆã®æŠ•ç¨¿æ™‚ã®ã¾ã¾ã€Œå…¥é–€ã€ã¨ãªã£ã¦ã„ã‚‹ã®ã§ã™ãŒã€å…ƒã€…å°‘ã—é€²ã‚“ã å†…å®¹ã‚‚æ›¸ã„ã¦ã„ãŸä¸Šã«ã€æ›´æ–°ã«ä¼´ã£ã¦é€²ã‚“ã å†…å®¹ãŒå¢—ãˆã¦ãã¦ã„ã¾ã™ã€‚

æœ¬å½“ã«å…¸å‹çš„ãªä½¿ç”¨æ³•ã¨ã€åŸºæœ¬çš„ãªè€ƒãˆæ–¹ã‚’æŠŠæ¡ã—ãŸã„æ–¹ã¯ã€è¨˜äº‹ã®åºç›¤ã ã‘ã‚’èª­ã‚€ã®ãŒè‰¯ã„ã¨æ€ã„ã¾ã™ã€‚
:::

## æ›´æ–°å±¥æ­´

- 2026/02/xx [Go1.25](https://go.dev/doc/go1.25)ã§è¨€èªä»•æ§˜æ›¸ã‹ã‚‰"core type"ã®ç”¨èªãŒå»ƒæ­¢ã•ã‚ŒãŸã“ã¨ã«å¯¾å¿œã—ã¾ã—ãŸã€‚
- 2024/01/03: [Go1.21(2023-08-08)](https://go.dev/doc/devel/release#go1.21.0)ã§`cmp`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«è¿½åŠ ã•ã‚ŒãŸã“ã¨ã«å¯¾å¿œã—ã¾ã—ãŸã€‚
- 2023/02/23: [Go1.20(2023-02-01)](https://go.dev/doc/devel/release#go1.20)ã®[`comparable`ã®ä»•æ§˜å¤‰æ›´](https://golang.org/doc/go1.20#language)ã«å¯¾å¿œã—ã¾ã—ãŸã€‚
  - æ¬¡ã®é–¢é€£è³‡æ–™ãŒã‚ã‚Šã¾ã™:
    - [The Go Blog - All your comparable types](https://go.dev/blog/comparable) Griesemeræ°ã«ã‚ˆã‚‹Goå…¬å¼ãƒ–ãƒ­ã‚°ã§ã™ã€‚
	- [Goè¨€èªã®Basic Interfaceã¯comparableã‚’æº€ãŸã™ã‚ˆã†ã«ãªã‚‹(ã§ã‚‚å®Ÿè£…ã™ã‚‹ã‚ˆã†ã«ã¯ãªã‚‰ãªã„)](https://zenn.dev/nobishii/articles/basic-interface-is-comparable) ä¸Šè¨˜ã®å†…å®¹ã«å¯¾ã™ã‚‹ç­†è€…ã®è§£èª¬è¨˜äº‹ã§ã™ã€‚Go1.20ãƒªãƒªãƒ¼ã‚¹å‰ã«æ›¸ã„ãŸã®ã§ç”¨èªãŒä½¿ãˆã¦ãªã„ã¨ã“ã‚ãŒã‚ã‚Šã¾ã™ã€‚

**ã‚·ãƒªãƒ¼ã‚º**

| ã‚¿ã‚¤ãƒˆãƒ« | å†…å®¹ | 
| ---- | ---- |
| Goè¨€èªã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å…¥é–€(1) | ã“ã®è¨˜äº‹ã§ã™ã€‚åŸºæœ¬çš„ãªã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®ä½¿ç”¨æ³•ã¨union, ~ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ |
| [Goè¨€èªã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å…¥é–€(2) ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã¨å‹æ¨è«–](https://zenn.dev/nobishii/articles/type_param_intro_2) | ã“ã®è¨˜äº‹ã®ç¶šç·¨ã§ã™ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã¨å‹æ¨è«–ã€ãã“ã§ä½¿ã‚ã‚Œã‚‹unificationã¨ã„ã†ãƒ«ãƒ¼ãƒãƒ³ã«ã¤ã„ã¦ã§ãã‚‹ã ã‘å³å¯†ã«èª¬æ˜ã—ã¾ã™ã€‚ |

## ç« ç›®æ¬¡

å®Ÿç”¨ä¸Šã¯æœ€åˆã®ã€ŒåŸºæœ¬åŸå‰‡ã¨ã‚·ãƒ³ãƒ—ãƒ«ãªä¾‹ã€ã¨ã„ã†ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å†…å®¹ã§ååˆ†ãªã“ã¨ãŒå¤šã„ã¨æ€ã„ã¾ã™ã€‚ã¨ã‚Šã‚ãˆãšã“ã“ã ã‘èª­ã‚€ã®ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚

| ã‚¿ã‚¤ãƒˆãƒ« | å†…å®¹ | 
| ---- | ---- |
| åŸºæœ¬åŸå‰‡ã¨ã‚·ãƒ³ãƒ—ãƒ«ãªä¾‹ | Goã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®åŸºæœ¬åŸå‰‡ã¨å…¸å‹çš„ãªä¾‹ã‚’è§£èª¬ã—ã¾ã™ã€‚ |
| `unions` | ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ä»¥å¤–ã®æ€§è³ªã‚’ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã«æ‰±ã„ãŸã„å ´åˆã«ä½¿ãˆã‚‹æ©Ÿèƒ½ã‚’è§£èª¬ã—ã¾ã™ã€‚|
| `~`ã¨underlying type | `unions`ã‚’ã•ã‚‰ã«ä½¿ã„ã“ãªã™ãŸã‚ã®æ–‡æ³•`~`ã‚’è§£èª¬ã—ã¾ã™ã€‚|
| core type | è¨€èªä»•æ§˜æ›¸èª­ã¿è¾¼ã¿å‹¢(?)å‘ã‘ã§ã™ã€‚ç¶šç·¨ã®å‰æçŸ¥è­˜ã«ãªã‚Šã¾ã™ã€‚|

# åŸºæœ¬åŸå‰‡ã¨ã‚·ãƒ³ãƒ—ãƒ«ãªä¾‹

Goã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®åŸºæœ¬åŸå‰‡ã¨ã‚·ãƒ³ãƒ—ãƒ«ãªä¾‹ã‚’èª¬æ˜ã—ã¾ã™ã€‚ã‚·ãƒ³ãƒ—ãƒ«ãªä¾‹ã¨è¨€ã£ã¦ã‚‚ã€ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã®å¤§åŠã¯ã“ã‚Œã§å°½ãã•ã‚Œã‚‹ã¨æ€ã„ã¾ã™ã®ã§ã€ã“ã®ç¯€ã ã‘èª­ã‚“ã§çµ‚ã‚ã‚Šã«ã™ã‚‹ã®ã‚‚ãŠã™ã™ã‚ã§ã™ã€‚

## Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®åŸºæœ¬åŸå‰‡

Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®åŸºæœ¬äº‹é …ã«ã¤ã„ã¦ã¯[Type Parameters Proposal](https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md)ã®å†’é ­ã«æŒ™ã’ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã†ã¡ç‰¹ã«é‡è¦ãªã®ã¯æ¬¡ã®2ã¤ã§ã™ã€‚ã“ã®2ã¤ã‚’è¦šãˆã‚Œã°Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ååˆ†ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã¨æ€ã„ã¾ã™ã€‚

- ã€Œé–¢æ•°ã€ã¨ã€Œå‹ã€ã¯ã€Œå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€ã‚’æŒã¤ã“ã¨ãŒã§ãã‚‹ã€‚
- ã€Œå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€ã®æº€ãŸã™ã¹ãæ€§è³ªã¯ã€Œã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã€ã‚’ã€Œå‹åˆ¶ç´„ã€ã¨ã—ã¦ä½¿ã†ã“ã¨ã§è¡¨ã™ã€‚

## å…·ä½“ä¾‹1: å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤é–¢æ•°`f[T Stringer]`

ã¾ãšã€Œå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤é–¢æ•°ã€ã®å…·ä½“ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

https://gotipplay.golang.org/p/NWxONCa85DL

```go
func main() {
	fmt.Println(f([]MyInt{1, 2, 3, 4}))
    // Output:
    // [1 2 3 4]
}

// fã¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤é–¢æ•°
// Tã¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
// ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹Stringerã¯ã€Tã«å¯¾ã™ã‚‹å‹åˆ¶ç´„ã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ã‚‹
func f[T Stringer](xs []T) []string {
	var result []string
	for _, x := range xs {
        // xã¯å‹åˆ¶ç´„Stringerã«ã‚ˆã‚ŠString()ãƒ¡ã‚½ãƒƒãƒ‰ãŒä½¿ãˆã‚‹
		result = append(result, x.String())
	}
	return result
}

type Stringer interface {
	String() string
}

type MyInt int

// MyIntã¯Stringerã‚’å®Ÿè£…ã™ã‚‹
func (i MyInt) String() string {
	return strconv.Itoa(int(i))
}
```

é–¢æ•°`f`ã®å®£è¨€æ™‚ã«`f[T Stringer]`ã¨ã„ã†å››è§’ã‚«ãƒƒã‚³ã®æ–‡æ³•è¦ç´ ãŒã¤ã„ã¦ã„ã¾ã™ã­ã€‚ã“ã‚ŒãŒå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ä¸€ç·’ã«å°å…¥ã•ã‚Œã‚‹æ–°ã—ã„æ–‡æ³•ã§ã™ã€‚ã“ã®æ„å‘³ã¯ã€

- é–¢æ•°`f`ã«ãŠã„ã¦å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã‚’å®£è¨€ã™ã‚‹
- `T`å‹ã¯ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹`Stringer`ã‚’æº€ãŸã™å‹ã§ã‚ã‚‹ã€ã¨ã„ã†å‹åˆ¶ç´„ã‚’è¨­ã‘ã‚‹

ã¨ã„ã†æ„å‘³ã§ã™ã€‚ã“ã®ã‚ˆã†ã«å®£è¨€ã—ãŸå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯é–¢æ•°ã®ä»–ã®éƒ¨åˆ†ã§å‚ç…§ã§ãã¾ã™ã€‚ä¾‹ãˆã°å¼•æ•°ã®å‹ã¨ã—ã¦`T`ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚ˆã£ã¦ã€`f[T Stringer](xs []T)`ã¨ã„ã†ã®ã¯ã€å¼•æ•°`xs`ã¨ã—ã¦å‹`T`ã®ã‚¹ãƒ©ã‚¤ã‚¹å‹`[]T`ã‚’å—ã‘å–ã‚‹ã€ã¨ã„ã†æ„å‘³ã«ãªã‚Šã¾ã™ã€‚

## å…·ä½“ä¾‹2: å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤å‹`Stack[T any]`

é–¢æ•°ã ã‘ã§ãªãã€å‹ã‚‚ã€Œå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚

ä¸€ä¾‹ã¨ã—ã¦ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã€Œã‚¹ã‚¿ãƒƒã‚¯ã€ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã™ã€‚

https://gotipplay.golang.org/p/jCS7vhCe_XC

```go
type Stack[T any] []T

func New[T any]() *Stack[T] {
	v := make(Stack[T], 0)
	return &v
}

func (s *Stack[T]) Push(x T) {
	(*s) = append((*s), x)
}

func (s *Stack[T]) Pop() T {
	v := (*s)[len(*s)-1]
	(*s) = (*s)[:len(*s)-1]
	return v
}

func main() {
	s := New[string]()
	s.Push("hello")
	s.Push("world")
	fmt.Println(s.Pop()) // world
	fmt.Println(s.Pop()) // hello
}
```

:::message

ã“ã®`Stack[T]`ã¯`Pop`ã—ãŸã‚ã¨ã‚‚stackã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç”Ÿãã¦ã„ã‚‹ã¨ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã—ã¾ã™ãŒã€ç°¡å˜ã®ãŸã‚ã“ã®ã¾ã¾ã«ã—ã¾ã™ã€‚

:::

ã¾ãšå‹å®šç¾©ã«ãŠã„ã¦ã€`type Stack[T any] []T`ã¨ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã—`string`ã«é™å®šã—ãŸã‚¹ã‚¿ãƒƒã‚¯ã§ã‚ã‚Œã°`type Stack []string`ã¨å®šç¾©ã™ã‚‹ã¨ã“ã‚ã§ã™ã€‚ã“ã®`string`ã®éƒ¨åˆ†ã‚’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã™ã‚‹ãŸã‚ã«`[T any]`ã‚’è¿½åŠ ã—ãŸã‚ã‘ã§ã™ã€‚

ã“ã“ã§ã€`any`ã¯æ–°ã—ãå°å…¥ã•ã‚Œã‚‹è­˜åˆ¥å­ã§ã€ç©ºã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹`interface{}`ã®åˆ¥åã§ã™ã€‚`any`ã‚’æ›¸ã‘ã‚‹ã¨ã“ã‚ã«ã¯ä»£ã‚ã‚Šã«`interface{}`ã‚’æ›¸ã„ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã—ã€ãã®é€†ã‚‚OKã§ã™ã€‚`Stack`ã®å†…å®¹ã«ãªã‚‹è¦ç´ å‹ã¯ä½•ã®å‹ã§ã‚ã£ã¦ã‚‚è‰¯ã„ã§ã™ã‹ã‚‰ã€`any`ã‚’å‹åˆ¶ç´„ã«ã™ã‚‹ã®ãŒé©åˆ‡ã§ã™ã€‚

:::message
ã¡ãªã¿ã«ã€`any`ã¯ã€Œäº‹å‰å®£è¨€ã•ã‚ŒãŸè­˜åˆ¥å­(predeclared identifier)ã€ã§ã‚ã£ã¦ã€Œäºˆç´„èª(keyword)ã€ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ãªã®ã§ã€`any := 1`ã®ã‚ˆã†ã«åŒã˜åå‰ã®è­˜åˆ¥å­ã§æ–°ãŸã«å¤‰æ•°å®šç¾©ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
:::

æ¬¡ã«ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚ã‚‹`New`é–¢æ•°ã‚’è¦‹ã¦ã¿ã¾ã™ã€‚å‹è‡ªä½“ãŒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚‚å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤é–¢æ•°ã¨ã—ã¦ã„ã¾ã™ã€‚

Stackã¯ãƒ¡ã‚½ãƒƒãƒ‰`Push`ã¨`Pop`ã‚’æŒã¡ã¾ã™ã€‚å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤å‹ã«å¯¾ã—ã¦ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®£è¨€ã™ã‚‹ã¨ãã¯ã€æ¬¡ã®ã‚ˆã†ãªæ§‹æ–‡ã‚’ä½¿ã„ã¾ã™ã€‚

```go
func(s *Stack[T]) Push(x T)
```

`*`ã¨ãƒã‚¤ãƒ³ã‚¿ã«ã—ã¦ã‚ã‚‹ã®ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¬ã‚·ãƒ¼ãƒã«ã™ã‚‹ãŸã‚ã§ã€ã“ã‚Œã¯å¾“æ¥é€šã‚Šã®æ–‡æ³•ã§ã™ã€‚å°‘ã—è¦šãˆã«ãã„ã®ã¯ãƒ¬ã‚·ãƒ¼ãƒã®å‹ã‚’`Stack[T]`ã®ã‚ˆã†ã«ã—ã¦å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã¤ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ã“ã‚ã§ã™ã€‚ã“ã®`T`ã‚’ãƒ¡ã‚½ãƒƒãƒ‰å†…ã®åˆ¥ãªå ´æ‰€ã§å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚`Push`ã®å ´åˆã¯å¼•æ•°ã®å‹ã¨ã—ã¦`(x T)`ã¨ä½¿ã£ã¦ã„ã¾ã™ã­ã€‚

æœ€å¾Œã«`main`ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```go
	s := New[string]()
```

ã¨ã„ã†è¡ŒãŒã‚ã‚Šã¾ã™ã­ã€‚é–¢æ•°å®£è¨€ã§ã¯ãªãã€é–¢æ•°å‘¼ã³å‡ºã—ã®æ–¹ã«`[string]`ãŒã¤ã„ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯å‹å¼•æ•°(type argument)ã§ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«å…·ä½“çš„ãªå‹ã‚’æ¸¡ã™ãŸã‚ã®æ§‹æ–‡ã§ã™ã€‚

å‹å¼•æ•°ã¯é€šå¸¸ã¯çœç•¥å¯èƒ½ã§ã™ã€‚ãã‚Œã¯ã€é–¢æ•°ã®å¼•æ•°ã®å‹ã¨å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒãƒ³ã‚°ã•ã›ã¦å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’**å‹æ¨è«–**ã§ãã‚‹å ´åˆãŒå¤šã„ã‹ã‚‰ã§ã™ã€‚ã—ã‹ã—ã€`New`é–¢æ•°ã«ã¯å¼•æ•°ãŒãªã„ãŸã‚ã€å…·ä½“çš„ãªå‹å¼•æ•°ã‚’æ¸¡ã•ãªã„ã¨å‹æ¨è«–ãŒã§ããšã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒå¤±æ•—ã—ã¾ã™ã€‚



### ãƒ¡ã‚½ãƒƒãƒ‰å®£è¨€ã«ãŠã„ã¦æ–°ãŸãªå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å®£è¨€ã§ããªã„

ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚é–¢æ•°ã®ä¸€ç¨®ãªã®ã§ã€ãƒ¡ã‚½ãƒƒãƒ‰å®£è¨€æ™‚ã«æ–°ãŸãªå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å®£è¨€ã§ãã‚‹ã®ã‹ã¨ã„ã†ç–‘å•ãŒæ¹§ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã§ããªã„ã“ã¨ã«ãªã£ã¦ã„ã¾ã™ã€‚

ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã¯æ›¸ã‘ã¾ã›ã‚“ã€‚

```go
// ã“ã‚Œã¯æ›¸ã‘ãªã„
func (s *Stack[T]) ZipWith[S,U any](x *Stack[S], func(T, S) U) *Stack[U] {
    // ...
}
```

ã“ã†ã„ã†ã“ã¨ã‚’ã—ãŸã‘ã‚Œã°ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãªã„é–¢æ•°ã¨ã—ã¦å®šç¾©ã™ã¹ãã§ã™ã€‚

```go
// ã“ã‚Œã¯æ›¸ã‘ã‚‹
func ZipWith[S,T,U any](x *Stack[T], y *Stack[S], func(T, S) U) *Stack[U] {
    // ...
}
```

:::message

å…·ä½“çš„ãªå®Ÿè£…ä¾‹ã¯ã“ã¡ã‚‰ã«ã‚ã‚Šã¾ã™: https://gotipplay.golang.org/p/-_HxaTjE_Zi

:::

## å…·ä½“ä¾‹3: å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤å‹`Set[T comparable]`

æ¬¡ã«ã€ã„ã‚ã‚†ã‚‹Setå‹ã‚’å®šç¾©ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

https://gotipplay.golang.org/p/ht_akn1eCGy

```go
type Set[T comparable] map[T]struct{}

func New[T comparable](xs ...T) Set[T] {
	s := make(Set[T])
	for _, xs := range xs {
		s.Add(xs)
	}
	return s
}

func (s Set[T]) Add(x T) {
	s[x] = struct{}{}
}

func (s Set[T]) Includes(x T) bool {
	_, ok := s[x]
	return ok
}

func (s Set[T]) Remove(x T) {
	delete(s, x)
}

func main() {
	s := New(1, 2, 3)
	s.Add(5)
	fmt.Println(s.Includes(3)) // true
	s.Remove(3)
	fmt.Println(s.Includes(3)) // false
}
```

å‹å®šç¾©ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚

```go
type Set[T comparable] map[T]struct{}
```

ã“ã“ã§ã€`comparable`ã¨ã„ã†æ–°ã—ã„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ãŒå‹åˆ¶ç´„ã«ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ãªãœ`any`ã§ã¯ãƒ€ãƒ¡ãªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

ãã‚Œã¯ã€`T`ã‚’`map`ã®keyã¨ã—ã¦ä½¿ã„ãŸã„ã‹ã‚‰ã§ã™ã€‚`map`ã¯keyã®å€¤ã«é‡è¤‡ãŒãªã„ã‚ˆã†ã«å€¤ã‚’ä¿ç®¡ã—ã¦ã„ããƒ‡ãƒ¼ã‚¿æ§‹é€ ãªã®ã§ã€é‡è¤‡ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã§ãã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã®åˆ¤å®šã«ã¯`==`åŠã³`!=`æ¼”ç®—å­ã«ã‚ˆã‚‹æ¯”è¼ƒãŒç”¨ã„ã‚‰ã‚Œã¾ã™ã€‚Goè¨€èªã§ã¯ã“ã®2ã¤ã®æ¼”ç®—å­ã«ã‚ˆã‚Šæ¯”è¼ƒã§ãã‚‹å‹ã¨æ¯”è¼ƒã§ããªã„å‹ãŒã‚ã‚‹ãŸã‚ã€ã€Œæ¯”è¼ƒå¯èƒ½ãªã™ã¹ã¦ã®å‹ã«ã‚ˆã‚Šæº€ãŸã•ã‚Œã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã€ãŒå¿…è¦ãªã®ã§ã™ã€‚

ã—ã‹ã—ãã®ã‚ˆã†ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ãƒ¦ãƒ¼ã‚¶ãŒå®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ãã“ã§Goè¨€èªã¯`comparable`ã¨ã„ã†ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’äºˆã‚å®šç¾©ã•ã‚ŒãŸã‚‚ã®ã¨ã—ã¦æä¾›ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚ã“ã‚Œã‚’ä½¿ãˆã°ã€genericã«ä½¿ãˆã‚‹`Set`å‹ã‚’ç°¡å˜ã«ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## Go1.17ã§ã§ããªã‹ã£ãŸã“ã¨

ã“ã“ã§å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çŸ¥ã‚‹ãŸã‚ã«ã€Go1.17ã§ã®ã‚³ãƒ¼ãƒ‰ã‚’è€ƒãˆã¦ã¿ã¾ã™ã€‚

### ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å—ã‘å–ã‚‹é–¢æ•°

ã¾ãšã€Go1.17ã«ãŠã„ã¦æ¬¡ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¨é–¢æ•°ã‚’è€ƒãˆã¾ã™ã€‚

```go
type Stringer interface {
    String() string
}

func f(xs []Stringer) []string {
    var result []string
    for _, x := range xs {
        result = append(result, x.String())
    }
    return result
}
```

ã¾ãŸã€æ¬¡ã®ã‚ˆã†ã«`Stringer`ã‚’å®Ÿè£…ã™ã‚‹å‹ã‚’ç”¨æ„ã—ã¾ã™ã€‚

```go
type MyInt int

// MyIntã¯Stringerã‚’å®Ÿè£…ã™ã‚‹
func(i MyInt) String() string {
    return strconv.Itoa(int(i))
}
```

ã“ã®ã¨ãæ¬¡ã®ã‚ˆã†ã«ã€`MyInt`ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’`f`ã«æ¸¡ã™ã“ã¨ã¯ã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ

```go
xs := []MyInt{0,1,2}
f(xs) // fã¯[]Stringerã‚’å—ã‘ä»˜ã‘ã‚‹
```

ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã¯æ›¸ã‘ã¾ã›ã‚“ã€‚`MyInt`ã¯`Stringer`ã‚’æº€ãŸã™ã®ã§`MyInt`å‹ã®å€¤ã¯`Stringer`å‹ã®å¤‰æ•°ã«ä»£å…¥å¯èƒ½ã§ã™ãŒã€`[]MyInt`å‹ã®å€¤ã¯`[]Stringer`å‹ã®å¤‰æ•°ã«ä»£å…¥ã§ããªã„ãŸã‚ã§ã™ã€‚

Go1.17ã§`[]Stringer`ã‚’ä¸€èˆ¬çš„ã«æ‰±ã†é–¢æ•°ã‚’æ›¸ãã«ã¯ã€æ¬¡ã®`f2`ã®ã‚ˆã†ã«ç©ºã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹`interface{}`ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ã™ã‚‹ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã“ã®é–¢æ•°`f2`ã«ã¯ã©ã‚“ãªå‹ã®å€¤ã§ã‚‚æ¸¡ã›ã¦ã—ã¾ã†ã®ã§ã€é–¢æ•°ã®åˆ©ç”¨å´ã§é–“é•ã£ãŸå€¤ã‚’æ¸¡ã•ãªã„ã‚ˆã†ã«æ°—ã‚’ã¤ã‘ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚

```go
// ã€æ³¨æ„ã€‘ Stringerã‚’å®Ÿè£…ã™ã‚‹å‹Tã®ã‚¹ãƒ©ã‚¤ã‚¹[]Tã ã‘ã‚’æ¸¡ã™ã“ã¨
func f2(xs interface{}) {
    if vs,ok := xs.([]MyInt); ok {
        // vsã«é–¢ã™ã‚‹å‡¦ç†
    }
    // ... 
}
```

:::message
`f2`ãŒ`[]MyInt`ä»¥å¤–ã®ã‚¹ãƒ©ã‚¤ã‚¹å‹ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ãã‚Œãã‚Œã®å‹ã«ã¤ã„ã¦ã®[å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³](https://go.dev/ref/spec##Type_assertions)ã‚’æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```go
if vs, ok := xs.([]Stringer); ok
```

ã®ã‚ˆã†ãªã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ›¸ãã“ã¨è‡ªä½“ã¯ã§ãã¾ã™ãŒã€ã“ã†æ›¸ã„ã¦ã‚‚`[]MyInt`å‹ã®å€¤ã‚’æ¸¡ã—ãŸã¨ãã«ã¯`!ok`ã¨ãªã‚Šã¾ã™ã€‚

å‹ã‚¹ã‚¤ãƒƒãƒæ–‡ã‚’ä½¿ã†å ´åˆã‚‚ã€æ¸¡ã™ã‹ã‚‚ã—ã‚Œãªã„å…·ä½“çš„ãªå‹ã”ã¨ã«caseç¯€ãŒå¿…è¦ã§ã™ã€‚
:::

### å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã‚ˆã‚‹è¨˜è¿°

> Stringerã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹å‹Tã®ã‚¹ãƒ©ã‚¤ã‚¹[]Tã ã‘ã‚’æ¸¡ã™ã“ã¨

ã¨ã„ã†æ¡ä»¶ä»˜ã‘ã¯ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ã†ã¨æ¬¡ã®ã‚ˆã†ã«è¨˜è¿°ã§ãã¾ã™ã€‚

```go
// fã¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤é–¢æ•°
// Tã¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
// ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹Stringerã¯ã€Tã«å¯¾ã™ã‚‹å‹åˆ¶ç´„ã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ã‚‹
func f[T Stringer](xs []T) []string {
	var result []string
	for _, x := range xs {
        // xã¯å‹åˆ¶ç´„Stringerã«ã‚ˆã‚ŠString()ãƒ¡ã‚½ãƒƒãƒ‰ãŒä½¿ãˆã‚‹
		result = append(result, x.String())
	}
	return result
}
```

ã“ã®`f`ã«ã¯`[]MyInt`å‹ã®å€¤ã ã‘ã§ãªãã€ä½•ã®ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ã‚‚ãªã—ã«`Stringer`ã‚’å®Ÿè£…ã™ã‚‹å‹`T`ã®ã‚¹ãƒ©ã‚¤ã‚¹`[]T`ã‚’æ¸¡ã›ã¾ã™ã€‚ã¾ãŸã€ãã†ã§ãªã„å‹ã®å€¤ã‚’æ¸¡ã—ãŸå ´åˆã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦æ¤œå‡ºã§ãã¾ã™ã€‚

## ã¾ã¨ã‚

- ã€Œé–¢æ•°ã€ã¨ã€Œå‹ã€ã¯ã€Œå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€ã‚’æŒã¤ã“ã¨ãŒã§ãã‚‹ã€‚
- ã€Œå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€ã®æº€ãŸã™ã¹ãæ€§è³ªã¯ã€Œã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã€ã‚’ã€Œå‹åˆ¶ç´„ã€ã¨ã—ã¦ä½¿ã†ã“ã¨ã§è¡¨ã™ã€‚
- é–¢æ•°ã‚„å‹ã®å¾Œã«`[T constraint]`ã¨ã„ã†æ–‡æ³•è¦ç´ ã‚’ã¤ã‘ã‚‹ã¨ã€ã€Œå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿Tã‚’å®£è¨€ã™ã‚‹ã€‚Tã¯`constraint`ã‚’æº€ãŸã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã€‚`constraint`ã¯å‹åˆ¶ç´„ã¨å‘¼ã°ã‚Œã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã‚’ç”¨ã„ã‚‹ã€‚
- ãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ ã§å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å®£è¨€ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚
- `any`ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯ç©ºã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹`interface{}`ã®åˆ¥åã§ã‚ã‚‹
- æ¯”è¼ƒå¯èƒ½ã€ã¤ã¾ã‚Š`==, !=`ã«ã‚ˆã‚‹ç­‰å€¤åˆ¤å®šãŒå¯èƒ½ãªå‹ã«ã‚ˆã‚Šæº€ãŸã•ã‚Œã‚‹`comparable`ãŒæä¾›ã•ã‚Œã‚‹ã€‚
- å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®é‡è¦ãªä½¿ã„æ–¹ã®1ã¤ã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚„ãƒãƒƒãƒ—ãªã©ã®ã„ã‚ã‚†ã‚‹ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã®æŠ½è±¡åŒ–ã§ã‚ã‚‹ã€‚

# `unions`

Go1.18ã§ã¯`unions`ã¨ã„ã†æ–‡æ³•è¦ç´ ã‚’ä½¿ã£ã¦ã€å¾“æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã¯è¡¨ç¾ã§ããªã„å‹åˆ¶ç´„ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## genericãªMaxé–¢æ•°ã¨unions

æ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®`math.Max`é–¢æ•°ã¯`func Max(x, y float64) float64`ã¨ã„ã†ã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã¡ã€`float64`ã®å€¤ã—ã‹æ¸¡ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚

ã›ã£ã‹ãå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã®ã§ã€genericãªMaxé–¢æ•°ã‚’ä½œã£ã¦ã¿ãŸã„ã¨æ€ã„ã¾ã™ã€‚ã¾ãšåˆã‚ã«æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’è€ƒãˆã¾ã—ãŸã€‚

```go
func Max(T any) (x, y T) T {
	if x >= y {
		return x
	}
	return y
}
```

ã¨ã“ã‚ãŒã€ã“ã®ã‚³ãƒ¼ãƒ‰ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚å®Ÿè¡Œã™ã‚‹ã¨æ¬¡ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚`T`ã®å‹åˆ¶ç´„ã¯`any`ãªã®ã§ã€æ¼”ç®—å­`>=`ã§æ¯”è¼ƒã§ãã‚‹ã¨ã¯é™ã‚‰ãªã„ã‹ã‚‰ã§ã™ã€‚


```
invalid operation: cannot compare x >= y (operator >= not defined on T)
```

> ç„¡åŠ¹ãªæ¼”ç®—: `x >= y`ã¨ã„ã†æ¯”è¼ƒã¯ã§ãã¾ã›ã‚“ã€‚(æ¼”ç®—å­ >= ã¯ å‹Tã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“)

ãã‚Œã§ã¯ã€é©å½“ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã‚’å®šç¾©ã—ã¦æ¼”ç®—å­`>=`ã§æ¯”è¼ƒã§ãã‚‹ã‚ˆã†ãªå‹åˆ¶ç´„ã«ã™ã‚‹ã“ã¨ã¯ã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ

Go1.17ã¾ã§ã¯ã€ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãªãœãªã‚‰ã€Go1.17ã¾ã§ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã¨ã¯ã€Œãƒ¡ã‚½ãƒƒãƒ‰ã‚»ãƒƒãƒˆã€ã™ãªã‚ã¡ãƒ¡ã‚½ãƒƒãƒ‰ã®é›†åˆï¼ˆé›†ã¾ã‚Šï¼‰ã‚’å®šç¾©ã™ã‚‹ã‚‚ã®ã§ã‚ã£ã¦ã€ã€Œã‚ã‚‹æ¼”ç®—å­ãŒä½¿ãˆã‚‹ã€ã¨ã„ã†ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ä»¥å¤–ã®å‹ã®æ€§è³ªã‚’è¡¨ã™ã“ã¨ã¯ã§ããªã„ã‹ã‚‰ã§ã™ã€‚

ãã“ã§Goè¨€èªã¯ã€ã€Œã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã€ã¨ã—ã¦æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã‚‚å®šç¾©ã§ãã‚‹ã‚ˆã†ã«æ©Ÿèƒ½ã‚’æ‹¡å¼µã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

```go
type Number interface {
    int | int32 | int64 | float32 | float64
}
```

ã“ã®`Number`ã¨ã„ã†ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã€`int, int32, int64, float32, float64`ã¨ã„ã†5ç¨®é¡ã®å‹ã«ã‚ˆã£ã¦ **ã€Œæº€ãŸã•ã‚Œã€ã¾ã™**ã€‚ã‹ã¤ã€ã“ã‚Œä»¥å¤–ã®å‹ã«ã‚ˆã£ã¦ã¯æº€ãŸã•ã‚Œã¾ã›ã‚“ã€‚
ã“ã®æ–‡æ³•è¦ç´ `int | int32 | int64 | float32 | float64`ã®ã“ã¨ã‚’`unions`ã‚„`union element`ã¨å‘¼ã³ã¾ã™ã€‚

:::message

`|`ã‚’ä½¿ã‚ãšã«ä¸€ã¤ã ã‘ã®å‹ã‚’æ›¸ã‘ã°ã€ãã®**ä¸€ã¤ã®å‹ã«ã‚ˆã£ã¦ã®ã¿æº€ãŸã•ã‚Œã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹**ã‚’å®šç¾©ã§ãã¾ã™ã€‚

```go
type Int interface {
    int
}
```

ã“ã®`Int`ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã®ã¯`int`å‹ã®ã¿ã§ã™ã€‚

:::

å¤§åˆ‡ãªã“ã¨ã¯ã€`Number`ã‚’å®Ÿè£…ã™ã‚‹å…¨ã¦ã®å‹ã¯ã€æ¼”ç®—å­`>=`ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€æ¬¡ã®ã‚ˆã†ãªé–¢æ•°ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

```go
type Number interface {
    int | int32 | int64 | float32 | float64
}

func Max[T Number] (x, y T) T {
	if x >= y {
		return x
	}
	return y
}
```

::: message

`>=`ãªã©ã§é †åºã¥ã‘ã‚‰ã‚Œã‚‹å‹ã¯ã“ã®5ã¤ä»¥å¤–ã«ã‚‚ã‚ã‚Šã¾ã™ãŒã€å…¨ã¦æ›¸ãå‡ºã™ã¨å¤§å¤‰ãªãŸã‚5ã¤ã ã‘æ›¸ãã¾ã—ãŸã€‚

:::

## for~rangeãŒä½¿ãˆã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹

å‹ã®æº€ãŸã™æ€§è³ªã«ã¯ã„ãã¤ã‹ç¨®é¡ãŒã‚ã‚Šã¾ã™ã€‚ã“ã“ã§ã„ãã¤ã‹æŒ™ã’ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

- ã‚ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ã¨ã„ã†æ€§è³ª
- `==, !=`ã§æ¯”è¼ƒã§ãã‚‹ã¨ã„ã†æ€§è³ª
- `<, >, >=, <=`ã§é †åºã¥ã‘ã‚‰ã‚Œã‚‹ã¨ã„ã†æ€§è³ª
- `for ~ range`æ–‡ã§ãƒ«ãƒ¼ãƒ—ã‚’å›ã™ã“ã¨ãŒã§ãã‚‹ã¨ã„ã†æ€§è³ª
- ã‚ã‚‹åå‰ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ã¨ã„ã†æ€§è³ª
- etc

ã€Œã‚ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ã¨ã„ã†æ€§è³ªã€ã¯å¾“æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã§è¡¨ç¾ã§ãã¾ã™ã€‚`==, !=`ã§æ¯”è¼ƒå¯èƒ½ãªæ€§è³ªã¯ã€çµ„ã¿è¾¼ã¿ã®`comparable`ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§è¡¨ç¾ã§ãã‚‹ã®ã§ã—ãŸã­ã€‚ãã—ã¦`<, >`ãªã©ã§é †åºã¥ã‘ã‚‰ã‚Œã‚‹æ€§è³ªã¯`unions`ã‚’åˆ©ç”¨ã—ãŸæ–°ã—ã„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§è¡¨ç¾ã§ãã‚‹ã“ã¨ã‚’ã¿ã¾ã—ãŸã€‚

æ¬¡ã«ã€`for ~ range`ã§ãƒ«ãƒ¼ãƒ—ã‚’å›ã›ã‚‹ã¨ã„ã†æ€§è³ªã‚’ã¿ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

é¢ç™½ã¿ã®ãªã„ä¾‹ã§ã™ãŒã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

https://gotipplay.golang.org/p/ec6KpsOHgHv

```go
type I interface {
	[]int 
}

func f[T I](x T) {
	for range x {
	}
}
```

`I`ã‚’å®Ÿè£…ã™ã‚‹å‹ã¯`[]int`ã®ã¿ã§ã€ã‹ã¤ã“ã®å‹ã¯`for range`ã§ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹å‹ã§ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã€`I`ã‚’å‹åˆ¶ç´„ã¨ã™ã‚‹å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å€¤ã«å¯¾ã—ã¦`for range`ãƒ«ãƒ¼ãƒ—ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

::: message

ã“ã“ã§ä»£ã‚ã‚Šã«
```go
type I interface {
	[]int | []string
}
```
ã¨ã™ã‚‹ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã‚‰ãªããªã‚Šã¾ã™ã€‚

> ./prog.go:11:12: cannot range over x (variable of type T constrained by I) (T has no core type)

ã“ã“ã§è¨€ã‚ã‚Œã¦ã„ã‚‹ã®ã¯`I`ãŒ"core type"ã‚’æŒãŸãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã®"core type"ã®èª¬æ˜ã¯æ¬¡ç« ã§è¡Œã„ã¾ã™ã€‚
:::

## `unions`ã‚’å«ã‚€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯å‹åˆ¶ç´„ã§ã—ã‹ä½¿ãˆãªã„

å‹åˆ¶ç´„ã§ã¯ãªãé€šå¸¸ã®å¤‰æ•°ã®å‹ã¨ã—ã¦`unions`ã‚’ä½¿ã†ã¨ã€ã„ã‚ã‚†ã‚‹sum typeã®ã‚ˆã†ãªã‚‚ã®ãŒå®šç¾©ã§ããã†ã«è¦‹ãˆã¾ã™ã€‚ã—ã‹ã—ã€ç¾åœ¨ã®ã¨ã“ã‚ã“ã‚Œã¯è¨±å¯ã•ã‚Œã¾ã›ã‚“ã€‚

```go
type IntString interface {
	int | string
}

var x IntString // ã“ã‚Œã¯ã§ããªã„
```

ã¤ã¾ã‚Šã€`unions`ã‚’ä½¿ã£ãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã¯å‹åˆ¶ç´„ã¨ã—ã¦ã—ã‹ä½¿ãˆãšã€é€šå¸¸ã®å¤‰æ•°ã®å‹ã¨ã—ã¦ã¯ä½¿ãˆã¾ã›ã‚“ã€‚

ã“ã®åˆ¶é™ã¯å°†æ¥çš„ã«å–ã‚Šé™¤ã‹ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å°å…¥ã ã‘ã§ã‚‚éå¸¸ã«å¤§ããªå¤‰æ›´ã§ã‚ã‚‹ãŸã‚ã€å®‰å…¨ã‚’æœŸã™ã‚‹ãŸã‚ã«ã¾ãšã¯æœ€ä½é™ã®æ©Ÿèƒ½ã§ãƒªãƒªãƒ¼ã‚¹ã—ã€å®Ÿéš›ã®ä½¿ã‚ã‚Œæ–¹ã‹ã‚‰ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’å¾—ã¦åˆ¤æ–­ã—ã¦ã„ãã®ã ã¨æ€ã„ã¾ã™ã€‚

## ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ã¨ã„ã†æ€§è³ªã¯å‹åˆ¶ç´„ã§æ‰±ãˆãªã„

ã§ããã†ã§ã§ããªã„ã“ã¨ã‚’1ã¤æŒ™ã’ã¦ãŠãã¾ã™ã€‚

ã€Œã‚ã‚‹åå‰ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ã€ã¨ã„ã†æ€§è³ªã‚’å‹åˆ¶ç´„ã§è¡¨ç¾ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

https://gotipplay.golang.org/p/WEM-yelirK1

```go
type I interface {
	X
}

type X struct {
	SomeField int
}

func f[T I](x T) {
	fmt.Println(x.X) // ã“ã‚Œã¯ã§ããªã„
}
```

## ã¾ã¨ã‚

- Goã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å‹åˆ¶ç´„ã‚’ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã«ã‚ˆã£ã¦è¡¨ç¾ã™ã‚‹ãŒã€å‹ã®æ€§è³ªã«ã¯ã€Œãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã€ä»¥å¤–ã®æ€§è³ªã‚‚ã‚ã‚‹ã€‚ãã®æ€§è³ªã®ä¸€éƒ¨ã¯`unions`ã‚’åˆ©ç”¨ã—ãŸæ–°ã—ã„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã«ã‚ˆã£ã¦è¡¨ç¾ã§ãã‚‹ã€‚
- `<, >, <=, >=`ã«ã‚ˆã‚‹é †åºä»˜å¯èƒ½æ€§ã¯`unions`ã‚’ä½¿ã£ã¦é †åºã¥ã‘ã‚‰ã‚Œã‚‹å‹ã®ã¿ã‚’åˆ—æŒ™ã™ã‚‹ã“ã¨ã§è¡¨ç¾ã§ãã‚‹ã€‚
- `for range`ãƒ«ãƒ¼ãƒ—ãŒã§ãã‚‹å‹ã‚’ä½¿ã£ã¦ã€ãã®1ã¤ã®å‹ã ã‘ã‹ã‚‰ãªã‚‹`unions`ã«ã‚ˆã‚‹å‹åˆ¶ç´„ã‚’ä½œã‚‹ã¨ã€ãã®å‹åˆ¶ç´„ã«å¾“ã†å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã®å€¤ã«ã¤ã„ã¦`for range`ãƒ«ãƒ¼ãƒ—ãŒã§ãã‚‹ã€‚
- `==, !=`ã«ã‚ˆã‚‹æ¯”è¼ƒå¯èƒ½æ€§ã¯`comparable`ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§è¡¨ç¾ã™ã‚‹(å†æ²)ã€‚
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ã¨ã„ã†æ€§è³ªã‚’å‹åˆ¶ç´„ã§è¡¨ã—ã¦ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã®å€¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‚ç…§ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚

# `~`ã¨underlying type

## ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³

å‰ç« ã§ã¯`unions`ã‚’ä½¿ã£ãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©ã«ã‚ˆã‚Šã€è¤‡æ•°ã®æ•°å€¤å‹ã«é©ç”¨ã§ãã‚‹genericãª`Max`é–¢æ•°ã‚’ä½œã‚Œã‚‹ã“ã¨ã‚’è¦‹ã¾ã—ãŸã€‚

```go
type Number interface {
    int | int32 | int64 | float32 | float64
}

func Max[T Number] (x, y T) T {
	if x >= y {
		return x
	}
	return y
}
```

ã§ã¯ã€æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã—ãŸ`NewInt`ã‚„`NewNewInt`ã«å¯¾ã—ã¦`Max`é–¢æ•°ã‚’ä½¿ç”¨ã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ

```go
type NewInt int

type NewNewInt NewInt
```

ã€Œã§ããªã„ã€ã¨ã„ã†ã®ãŒç­”ãˆã§ã™ã€‚`int, NewInt, NewNewInt`ã¯ãã‚Œãã‚Œç›¸ç•°ãªã‚‹å‹ã§ã‚ã‚Šã€ã—ãŸãŒã£ã¦`NewInt`ã¨`NewNewInt`ã¯`Number`ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ãªã„ã‹ã‚‰ã§ã™ã€‚

## `~`ã‚’ã¤ã‹ã£ã¦underlying typeã‚’ãƒãƒƒãƒãƒ³ã‚°ã™ã‚‹

`NewInt`ã‚„`NewNewInt`ã‚‚æ•°å€¤å‹ã§ã‚ã‚‹ã“ã¨ã«å¤‰ã‚ã‚Šã¯ãªãã€`>=`ãªã©ã®æ¼”ç®—å­ã§æ¯”è¼ƒã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã‹ã‚‰ã€ã“ã®ã‚ˆã†ãªå‹ã‚’è¨±ã™ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½œã‚ŠãŸã„ã§ã™ã€‚

ã‚‚ã¡ã‚ã‚“ã€`NewInt`ã‚’ç›´æ¥unionsã«åŠ ãˆã‚Œã°`NewInt`ã«`Number`ã‚’å®Ÿè£…ã•ã›ã‚‹ã“ã¨ã¯ã§ãã¾ã™:

```go
// NewIntã¨NewNewIntãŒNumberã‚’å®Ÿè£…ã™ã‚‹ã‚ˆã†ã«ãªã£ãŸ
type Number interface { 
    int | int32 | int64 | float32 | float64 | NewInt | NewNewInt
}
```

ã—ã‹ã—ã€ã€Œ`int`ã‚’å…ƒã«ã—ã¦å‹å®šç¾©ã§ä½œã‚‰ã‚Œã‚‹æ–°ã—ã„å‹ã€ã¯ç„¡é™ã«ã‚ã‚‹ã®ã§ã€ãã‚Œã‚‰å…¨ã¦ãŒ`Number`ã‚’å®Ÿè£…ã™ã‚‹ã‚ˆã†ã«ã—ãŸã„ã§ã™ã€‚ãã®ãŸã‚ã®æ–‡æ³•ã¨ã—ã¦ã€Goè¨€èªã¯`~`ã‚’å°å…¥ã—ã¾ã—ãŸã€‚

```go
type Number interface { 
    ~int | ~int32 | ~int64 | ~float32 | ~float64
}
```

ã“ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹ã¨ã€ã€Œ`int, int32, int64, float32, float64`ã®ã†ã¡ã„ãšã‚Œã‹ã‚’underlying typeã¨ã™ã‚‹å‹ã€ã™ã¹ã¦ãŒ`Number`ã‚’å®Ÿè£…ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

::: message

underlying typeã«ã¤ã„ã¦ã¯æ¬¡ã®ç¯€ã§èª¬æ˜ã—ã¾ã™ã€‚

:::

ã“ã‚Œã«ã‚ˆã‚Šã€æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãŒæ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```go
type Number interface { 
    ~int | ~int32 | ~int64 | ~float32 | ~float64
}

func Max[T Number] (x, y T) T {
	if x >= y {
		return x
	}
	return y
}

var x y NewInt = 1, 2

max := Max(x, y) // max == NewInt(2)
```

:::message

Proposalæ®µéšã§ã¯`~int`ã®ã‚ˆã†ãªè¦ç´ ã¯è¿‘ä¼¼è¦ç´ (approximation element)ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã—ãŸã€‚

ã“ã‚Œã¯ã¤ã¾ã‚Š`type MyInt int`ã®ã‚ˆã†ãªå‹ã¯`int`ã«ã€Œä¼¼ã¦ã„ã‚‹ã€å‹ã§ã‚ã‚‹ã¨ã„ã†æ°—æŒã¡ãŒè¾¼ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã¨æ€ã„ã¾ã™ã€‚
â€»ç‰©ç†å­¦ã‚„å·¥å­¦ã§ã¯`x ~ 1000`ã®ã‚ˆã†ãªè¨˜æ³•ã§ã€Œ`x`ã¯1000ã«è¿‘ã„ã€ã¨ã„ã†æ„å‘³ã‚’è¡¨ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

:::

## underlying type

Goè¨€èªã®å…¨ã¦ã®å‹ã¯ã€ãã‚Œã«å¯¾å¿œã™ã‚‹"underlying type"ã¨ã„ã†å‹ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

1ã¤ã®å‹ã«å¯¾ã—ã¦ã€å¯¾å¿œã™ã‚‹underlying typeã¯å¿…ãš1ã¤ã ã‘å­˜åœ¨ã—ã¾ã™ã€‚underlying typeã‚’æŒãŸãªã„å‹ã‚„ã€underlying typeã‚’2ã¤ä»¥ä¸ŠæŒã¤å‹ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚

### å…·ä½“ä¾‹

ã¾ãšå…·ä½“ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã™ã€‚

```go
type NewInt int // NewIntã®underlying typeã¯int

type NewNewInt NewInt // NewNewIntã®underlying typeã‚‚int

// intã®underlying typeã¯int

type IntSlice []int // IntSliceã®underlying typeã¯[]int

// []intã®underlying typeã¯[]int
```

å¤§ã¾ã‹ã«ã„ã†ã¨ã€`type A B`ã¨ã„ã†å½¢ã®å‹å®šç¾©ã‚’å·¦ã‹ã‚‰å³ã«é¡ã£ã¦ã‚†ãã€ãã‚Œä»¥ä¸Šé¡ã‚Œãªã„ã¨ã“ã‚ã«ã‚ã‚‹å‹ãŒunderlying typeã§ã™ã€‚

### å³å¯†ãªå®šç¾©(Go 1.17)

https://go.dev/ref/spec##Types ã«ã‚ˆã‚‹ã¨ã€

> Each type T has an underlying type: If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T's underlying type is the underlying type of the type to which T refers in its type declaration.

ã¨ã‚ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šã€

- `T`ãŒäº‹å‰å®£è¨€ã•ã‚ŒãŸboolean, æ•°å€¤, æ–‡å­—åˆ—å‹ã‚„å‹ãƒªãƒ†ãƒ©ãƒ«ã®ã¨ãã€`T`ã®underlying typeã¯`T`è‡ªèº«ã§ã‚ã‚‹
- ãã‚Œä»¥å¤–ã®å ´åˆã€(`T`ã¯`type T X`ã®ã‚ˆã†ã«å®šç¾©ã•ã‚ŒãŸå‹ãªã®ã§)`T`ã®underlying typeã¯`X`ã®underlying typeã§ã‚ã‚‹

ã®ã‚ˆã†ã«å†å¸°çš„ãªå®šç¾©ã«ãªã£ã¦ã„ã¾ã™ã€‚

::: message
ãªãŠã€`T`ãŒå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã®å ´åˆã€`T`ã®underlying typeãã®å‹åˆ¶ç´„ã®underlying typeã§ã™ã€‚ä¸Šè¨˜å¼•ç”¨ç®‡æ‰€ã¯Go1.17ã®ä»•æ§˜æ›¸ãªã®ã§ã“ã‚ŒãŒè¨€åŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
:::

ã‚ˆã‚Šä¸å¯§ãªè§£èª¬ã‚’è¦‹ãŸã„ã‹ãŸã¯ã€DQNEOã•ã‚“ã«ã‚ˆã‚‹æ¬¡ã®ç™ºè¡¨ã‚’è¦‹ã‚‹ã®ãŒè‰¯ã„ã¨æ€ã„ã¾ã™ã€‚

- https://www.youtube.com/watch?v=mlg1Scnm44Q&t=3148s
- [ä¸Šè¨˜ç™ºè¡¨ã®ã‚¹ãƒ©ã‚¤ãƒ‰](https://speakerdeck.com/dqneo/go-language-underlying-type)

## `cmp`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸

`<, >`ã§é †åºã¥ã‘ã§ãã‚‹å‹ã‚’`unions`ã§åˆ—æŒ™ã§ãã‚‹ã“ã¨ã¯åˆ†ã‹ã‚Šã¾ã—ãŸãŒã€å®Ÿéš›ã«å…¨ã¦ã®å‹ã‚’æ›¸ã“ã†ã¨ã™ã‚‹ã¨é¢å€’ã ãªã¨æ€ã‚ã‚ŒãŸæ–¹ã‚‚ã„ã‚‹ã¨æ€ã„ã¾ã™ã€‚

ãã“ã§ã€`<, >`ã§é †åºã¥ã‘ã§ãã‚‹å‹ã«ã‚ˆã£ã¦æº€ãŸã•ã‚Œã‚‹å‹åˆ¶ç´„ã¯æ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸`cmp`ã®[`cmp.Ordered`](https://pkg.go.dev/cmp#Ordered)ã¨ã—ã¦æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚

å®Ÿè£…ã¯æ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

```go
// Ordered is a constraint that permits any ordered type: any type
// that supports the operators < <= >= >.
// If future releases of Go add new ordered types,
// this constraint will be modified to include them.
//
// Note that floating-point types may contain NaN ("not-a-number") values.
// An operator such as == or < will always report false when
// comparing a NaN value with any other value, NaN or not.
// See the [Compare] function for a consistent way to compare NaN values.
type Ordered interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64 |
		~string
}
```

ã“ã‚Œã‚’ä½¿ã£ã¦ã€ä¸€èˆ¬çš„ãª`Max`é–¢æ•°ã‚’å®šç¾©ã§ãã¾ã™ã€‚

https://go.dev/play/p/-WB97e8w2NC

```go
package main

import (
	"cmp"
	"fmt"
)

type NewInt int

var x, y NewInt = 3, 2

func main() {
	fmt.Println(Max(x, y)) // 3
}

func Max[T cmp.Ordered](x, y T) T {
	if y > x {
		return y
	}
	return x
}
```

## `unions`ã®è¦ç´ ã¨ã—ã¦ã©ã‚“ãªå‹ã§ã‚‚æ›¸ã„ã¦ã„ã„ã®ã‹

ç´°ã‹ã„è©±ã«ãªã‚Šã¾ã™ãŒã€`unions`ã®è¦ç´ ã¨ã—ã¦ä½¿ãˆã‚‹å‹ã«ã¤ã„ã¦ã¯ã€å°‘ã—åˆ¶ç´„ãŒã‚ã‚Šã¾ã™ã€‚

`unions`ãŒè¤‡æ•°è¦ç´ ã‹ã‚‰ãªã‚‹ã¨ãã€ãã®è¦ç´ ã«ãªã‚Œã‚‹ã®ã¯

- éã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹
- ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã‚’å«ã¾ãªã„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹

ã§ã™ã€‚ã¤ã¾ã‚Šã€`fmt.Stringer`ã®ã‚ˆã†ã«`String() string`ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã‚’å«ã‚“ã§ã„ã‚‹å‹ã¯è¤‡æ•°è¦ç´ ã‹ã‚‰ãªã‚‹`unions`ã®è¦ç´ ã¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚

:::message
å³å¯†ã«ã„ã†ã¨ã€

- ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã‚’å«ã‚€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã¯è¨±å¯ã•ã‚Œãªã„
- è¨±å¯ã•ã‚Œãªã„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã‚’åŸ‹ã‚è¾¼ã‚“ã ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯è¨±å¯ã•ã‚Œãªã„

ã¨ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚‚è¤‡æ•°è¦ç´ `unions`ã®è¦ç´ ã«ãªã‚Œã¾ã›ã‚“ã€‚

```go
type I interface { // è¨±å¯ã•ã‚Œãªã„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’åŸ‹ã‚è¾¼ã‚“ã ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãªã®ã§è¨±å¯ã•ã‚Œãªã„
	fmt.Stringer // ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã‚’å«ã‚€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãªã®ã§è¨±å¯ã•ã‚Œãªã„
}
```
:::

:::message
ã“ã“ã§ã€Œè¤‡æ•°è¦ç´ ã®ã€ã¨æ–­ã£ãŸã®ã¯ã€å˜ä¸€è¦ç´ ã€ã¤ã¾ã‚Š`|`ã‚’å«ã¾ãªã„`unions`ã«ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã‚’ä½¿ã†ã®ã¯ã€å¾“æ¥ã‹ã‚‰ã‚ã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹å‹ã®ã€ŒåŸ‹ã‚è¾¼ã¿ã€ã¨åŒã˜ã“ã¨ã ã‹ã‚‰ã§ã™ã€‚

```go
type I interface {
	fmt.Stringer // å˜ä¸€è¦ç´ ã®unionsã«ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½¿ã†ã®ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®åŸ‹ã‚è¾¼ã¿ã¨åŒã˜ã“ã¨
}
```
:::

:::message
ã“ã®ã‚ˆã†ãªåˆ¶é™ã‚’è¨­ã‘ã¦ã„ã‚‹ç†ç”±ã¯ã€ã“ã‚Œã‚’è¨±å¯ã™ã‚‹ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®å®Ÿè£…ãŒè¤‡é›‘ã«ãªã‚‹ã‚ã‚Šã«ãã‚Œã»ã©æœ‰ç”¨æ€§ã¯ãªã„ã‹ã‚‰ã ã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚
ãŸã ã—ã€å®Ÿè£…ãŒä¸å¯èƒ½ã¨è€ƒãˆã‚‰ã‚Œã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã‚ˆã†ã§ã€ã‚‚ã—ã“ã®ã‚ˆã†ãªå®šç¾©ãŒå¿…è¦ã ã¨å°†æ¥åˆ¤æ–­ã•ã‚Œã‚Œã°è¨±å¯ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹å¯èƒ½æ€§ã‚‚ã‚ã‚Šã¾ã™ã€‚

ã“ã®ç‚¹ã«ã¤ã„ã¦ã¯ç­†è€…è³‡æ–™ã®[Type Sets Proposalã‚’èª­ã‚€(2)](https://zenn.dev/nobishii/articles/type_set_proposal_2)ã§è­°è«–ã—ã¦ã„ã¾ã™ã€‚
:::

## ã¾ã¨ã‚

- `~`ã‚’ã¤ã‹ã†ã¨å‹å®šç¾©ã«ã‚ˆã£ã¦ä½œã‚Šã†ã‚‹ç„¡é™ã®å‹ã«ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹
- `~T`ã¯`T`ã‚’underlying typeã«æŒã¤ã™ã¹ã¦ã®å‹ã‚’è¡¨ã™

# ã§ããã†ã§ã§ããªã„ã“ã¨

ã“ã“ã¾ã§ã®å†…å®¹ã§ã€Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§ã§ãã‚‹ã“ã¨ã®å¤§åŠã¯èª¬æ˜ã—ã¾ã—ãŸã€‚ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã€Œã§ããã†ã§ã§ããªã„ã“ã¨ã€ã‚’èª¬æ˜ã—ã¾ã—ã‚‡ã†ã€‚ãŸã åˆ—æŒ™ã—ã¦ã‚‚è‰¯ã„ã®ã§ã™ãŒã€ã‚ˆã‚Šè‰¯ã„ç†è§£ã®ãŸã‚ã€ **Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§ã€Œã§ããã†ãªã“ã¨ã€ã¨ã¯ãã‚‚ãã‚‚ä½•ãªã®ã‹ã‚’è€ƒãˆã¦ã¿ã¾ã™ã€‚** 

ãã®ãŸã‚ã«ã€Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ãŒã©ã†ã„ã†ã‚‚ã®ã ã£ãŸã‹ãŠã•ã‚‰ã„ã—ã¾ã™ã€‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãªé–¢æ•°ã®å ´åˆã§è€ƒãˆã‚‹ã¨ã€å‹åˆ¶ç´„ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§å®£è¨€ã•ã‚Œã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é–¢æ•°ã®body(å®Ÿè£…)ã®ãªã‹ã§ã‚ãŸã‹ã‚‚å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«ä½¿ã£ã¦è‰¯ã„ã®ã§ã—ãŸã€‚ã“ã‚Œã‚’ç¤ºã™ãŸã‚ã€ã“ã®è¨˜äº‹ã®æœ€åˆã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å†æ²ã—ã¾ã™:

```go
// fã¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒã¤é–¢æ•°
// Tã¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
// ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹Stringerã¯ã€Tã«å¯¾ã™ã‚‹å‹åˆ¶ç´„ã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ã‚‹
func f[T Stringer](xs []T) []string {
	var result []string
	for _, x := range xs {
        // xã¯å‹åˆ¶ç´„Stringerã«ã‚ˆã‚ŠString()ãƒ¡ã‚½ãƒƒãƒ‰ãŒä½¿ãˆã‚‹
		result = append(result, x.String())
	}
	return result
}

type Stringer interface {
	String() string
}

type MyInt int

// MyIntã¯Stringerã‚’æº€ãŸã™
func (i MyInt) String() string {
	return strconv.Itoa(int(i))
}
```

è¨€ã„æ›ãˆã‚‹ã¨ã€ **ã€Œå‹åˆ¶ç´„ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦`String()`ãŒä½¿ãˆã‚‹ãªã‚‰ã°ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã«å¯¾ã—ã¦ã‚‚`String()`ãŒä½¿ãˆã‚‹ã€** ã¨ã„ã†ã®ãŒGoã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°ã ã¨è¨€ã£ã¦ã‚‚è‰¯ã•ãã†ã§ã™ã€‚

ã‚‚ã—ã‚‚ã€ã“ã®æ–‡ã‚’ä¸€èˆ¬åŒ–ã—ãŸ **ã€Œå‹åˆ¶ç´„ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦æ“ä½œXãŒå¯èƒ½ãªã‚‰ã°ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã«å¯¾ã—ã¦ã‚‚æ“ä½œXãŒå¯èƒ½ã§ã‚ã‚‹ã€** ã¨ã„ã†ãƒ†ãƒ¼ã‚¼ãŒæˆã‚Šç«‹ã¤ãªã‚‰éå¸¸ã«åˆ†ã‹ã‚Šã‚„ã™ãã€ã‚ã‚‹æ„å‘³ã§ç†æƒ³çš„ã§ã™ã€‚Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã«å¯¾ã—ã¦ã€Œã§ããã†ãªã“ã¨ã€ã ã¨ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ãŒæœŸå¾…ã™ã‚‹ã“ã¨ã®å¤šãã¯ã€ã“ã®ãƒ†ãƒ¼ã‚¼ãŒæˆã‚Šç«‹ã¤ã¨ã„ã†æœŸå¾…ã«åŸºã¥ã„ã¦ã„ã‚‹ã¨æ€ã„ã¾ã™ã€‚ã“ã‚Œã‚’ã“ã®è¨˜äº‹ã§ã¯ã€ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã® **ã€Œç†æƒ³ã®ãƒ†ãƒ¼ã‚¼ã€** ã¨å‘¼ã¶ã“ã¨ã«ã—ã¾ã™ã€‚

ã—ã‹ã—ã€2026å¹´2æœˆ(Go1.25)ç¾åœ¨ã€ã“ã®ãƒ†ãƒ¼ã‚¼ã¯å¿…ãšã—ã‚‚æˆã‚Šç«‹ã¡ã¾ã›ã‚“ã€‚"æ“ä½œX"ã«æ§˜ã€…ãªã‚‚ã®ã‚’å½“ã¦ã¯ã‚ã¦ã€ãã‚Œã‚’ã¿ã¦ã„ãã¾ã—ã‚‡ã†ã€‚


:::message
Goã®å…¬å¼ãƒ–ãƒ­ã‚° https://go.dev/blog/coretypes ã«ãŠã„ã¦ã‚‚ã€å…ƒã€…ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®è¨­è¨ˆæ€æƒ³ã¯æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã£ãŸã€ã¨æ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚

> an operation involving operands of generic type should be valid if it is valid for any type permitted by the respective type constraint.

> ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãªå‹ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã«ä¿‚ã‚‹æ¼”ç®—ã¯ã€ãã®æ¼”ç®—ãŒã€å¯¾å¿œã™ã‚‹å‹åˆ¶ç´„ã«ã‚ˆã£ã¦è¨±ã•ã‚Œã‚‹å…¨ã¦ã®å‹ã«å¯¾ã—ã¦æœ‰åŠ¹ãªã‚‰ã°ã€æœ‰åŠ¹ã§ã‚ã‚‹ã¹ãã ã€‚
:::

| æ“ä½œX | ã€Œç†æƒ³ã®ãƒ†ãƒ¼ã‚¼ã€ãŒæˆã‚Šç«‹ã¤ã‹ã©ã†ã‹ | 
| ---- | ---- |
| ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã— | æˆã‚Šç«‹ã¤ |
| äºŒé …æ¼”ç®—| æˆã‚Šç«‹ã¤ |
| å˜é …æ¼”ç®—| æˆã‚Šç«‹ã¤ |
| `nil`ã®ä»£å…¥ | æˆã‚Šç«‹ã¤ |
| å‹ãƒªãƒ†ãƒ©ãƒ«å‹ã®å€¤ã®ä»£å…¥ | æˆã‚Šç«‹ã¤ |
| for ~ rangeãƒ«ãƒ¼ãƒ—| æˆã‚Šç«‹ãŸãªã„ |
| æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®èª­ã¿æ›¸ã| æˆã‚Šç«‹ãŸãªã„|
| ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼| æˆã‚Šç«‹ã¤ |
| ãƒãƒ£ãƒãƒ«ã®é€å—ä¿¡| æˆã‚Šç«‹ãŸãªã„ |

ä»¥ä¸‹ã€ã“ã‚Œã‚‰ã‚’å…·ä½“çš„ã«ã¿ã¦ã„ãã¾ã™ãŒã€å…¥é–€æ®µéšã§ã¯ç´°ã‹ã™ãã‚‹ä»•æ§˜ã ã¨æ€ã†ã®ã§ã€æ°—ã«ãªã£ãŸã¨ãã«å‚ç…§ã™ã‚‹ç¨‹åº¦ã§ã”åˆ©ç”¨ã„ãŸã ã‘ã‚Œã°è‰¯ã„ã¨æ€ã„ã¾ã™ã€‚

## ã€Œç†æƒ³ã®ãƒ†ãƒ¼ã‚¼ã€ãŒæˆã‚Šç«‹ã¤æ“ä½œ

æ¬¡ã®è¡¨ã®ãã‚Œãã‚Œã®è¡Œã«ã‚ã‚‹ã€Œæ“ä½œXã€ã«ã¤ã„ã¦ã¯ã€ **ã€Œå‹åˆ¶ç´„ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦æ“ä½œXãŒå¯èƒ½ãªã‚‰ã°ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã«å¯¾ã—ã¦ã‚‚æ“ä½œXãŒå¯èƒ½ã§ã‚ã‚‹ã€** ã¨ã„ã†ãƒ†ãƒ¼ã‚¼ãŒæˆã‚Šç«‹ã¡ã¾ã™ã€‚

TODO: è¡¨

### `nil`ã®ä»£å…¥

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦`nil`ã‚’ä»£å…¥ã§ãã‚‹ãªã‚‰ã°ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã®å¤‰æ•°ã«ã‚‚`nil`ã‚’ä»£å…¥å¯èƒ½ã§ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

```go
type Constraint interface {
	[]int | ~[]string | *bool
}

func f[T Constraint]() {
	var _ T = nil
}
```
https://go.dev/play/p/cH5ktnw3Yck


:::message
ä»•æ§˜ä¸Šã®æ ¹æ‹ ã¯ https://go.dev/ref/spec#Assignability ã«ã‚ã‚Šã¾ã™ã€‚
:::

### å‹ãƒªãƒ†ãƒ©ãƒ«ã®å€¤ã®ä»£å…¥

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦å‹ãƒªãƒ†ãƒ©ãƒ«ã§è¡¨ã•ã‚Œã‚‹å‹`V`ã®å€¤ãŒä»£å…¥å¯èƒ½ãªã‚‰ã°ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã®å¤‰æ•°ã«ã‚‚`V`ã®å€¤ã‚’ä»£å…¥å¯èƒ½ã§ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

```go
type Constraint interface {
	DefinedIntSliceA | DefinedIntSliceB
}

type DefinedIntSliceA []int
type DefinedIntSliceB []int

func f[T Constraint]() {
	var _ T = []int{}
}
```
https://go.dev/play/p/R21YGC2O8nV

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦ã€ãã®å€¤ãŒå‹ãƒªãƒ†ãƒ©ãƒ«ã§è¡¨ã•ã‚Œã‚‹å‹`V`ã®å¤‰æ•°ã«ä»£å…¥å¯èƒ½ãªã‚‰ã°ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã®å€¤ã¯`V`ã®å¤‰æ•°ã«ä»£å…¥å¯èƒ½ã§ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

```go
type Constraint interface {
	DefinedIntSliceA | DefinedIntSliceB
}

type DefinedIntSliceA []int
type DefinedIntSliceB []int

func f[T Constraint]() {
	var t T
	var _ []int = t
}
```

https://go.dev/play/p/8ifyI02FINX

### Representability(è¡¨ç¾å¯èƒ½æ€§)

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã‚ˆã£ã¦ã€ã‚ã‚‹å‹ãªã—å®šæ•°`c`ãŒè¡¨ç¾å¯èƒ½ãªã‚‰ã°ã€ãã®å‹ãªã—å®šæ•°`c`ã¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã«ã‚ˆã£ã¦è¡¨ç¾å¯èƒ½ã§ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

```go
type Constraint interface {
	complex128 | float64
}

func f[T Constraint]() {
	const c = 1.1
	var _ T = c // è¡¨ç¾å¯èƒ½ãªã®ã§ä»£å…¥å¯èƒ½ã§ã‚ã‚‹
}
```
https://go.dev/play/p/FJO4JhKl09x

### title

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

```go
```

### title

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

```go
```

### title

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚

```go
```


## ã§ããªã„


### å®šæ•°å®£è¨€

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦ã€ãã®å‹ã‚’æŒã¤å®šæ•°ã‚’å®šæ•°å¼`exp`ã§å®£è¨€ã§ãã‚‹ã¨ã—ã¦ã‚‚ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã®å‹ã‚’æŒã¤å®šæ•°ã‚’å®£è¨€ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

å®šæ•°å®£è¨€ã®å‹ã¨ã—ã¦å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã‚’ä½¿ã†ã“ã¨è‡ªä½“ãŒã§ããªã„ãŸã‚ã§ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã›ã‚“ã€‚

```go
type Constraint interface {
	complex128 | float64
}

func f[T Constraint]() {
	const exp = 1.1
	const _ T = exp
}
```
https://go.dev/play/p/HKUPvDpkLmm

### ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒªãƒ†ãƒ©ãƒ«ã®ä½¿ç”¨

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦ã€ãã®å‹ã®ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒªãƒ†ãƒ©ãƒ«ãŒä½¿ãˆã‚‹ã¨ã—ã¦ã‚‚ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã®ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆãƒªãƒ†ãƒ©ãƒ«ãŒä½¿ãˆã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚

è¿½åŠ æ¡ä»¶ã¨ã—ã¦ã€`T`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ãŒã€åŒä¸€ã®underlying typeã‚’æŒã¤å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã›ã‚“ã€‚

```go
type Constraint interface {
	[]int | [1]int
}

func f[T Constraint]() {
	var _ = T{}
}
```

https://go.dev/play/p/Ogs7lmQL3Cj



### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ã®ä½¿ç”¨

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦ã€ãã®å‹ã®å¼ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ãŒä½œã‚Œã‚‹ã¨ã—ã¦ã‚‚ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã®å¼ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ãŒä½¿ãˆã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚

è¿½åŠ æ¡ä»¶ã¨ã—ã¦ã€`T`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ãŒã€åŒä¸€ã®è¦ç´ å‹ã‚’æŒã¤å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã›ã‚“ã€‚
```go
type Constraint interface {
	[1]int | [1]string // ã©ã¡ã‚‰ã‚‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ãŒä½œã‚Œã‚‹ãŒã€è¦ç´ å‹ãŒintã¨stringã§ç•°ãªã‚‹
}

func f[T Constraint]() {
	var t T
	_ = t[0] // ã“ã®ã‚ˆã†ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ã¯ç„¡åŠ¹
}
```
https://go.dev/play/p/G1JrWC1UQKm

:::message
è¨€èªä»•æ§˜ä¸Šã®æ ¹æ‹ ã¯æ¬¡ã®ç®‡æ‰€ã«ã‚ã‚Šã¾ã™ã€‚
https://go.dev/ref/spec#Index_expressions

> The element types of all types in P's type set must be identical.
:::

### ã‚¹ãƒ©ã‚¤ã‚¹å¼ã®ä½¿ç”¨

å‹åˆ¶ç´„`Constraint`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ã«ã¤ã„ã¦ã€ãã®å‹ã®å¼ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹å¼ãŒä½œã‚Œã‚‹ã¨ã—ã¦ã‚‚ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`T`ã®å¼ã«ã‚¹ãƒ©ã‚¤ã‚¹å¼ãŒä½¿ãˆã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚

è¿½åŠ æ¡ä»¶ã¨ã—ã¦ã€`T`ã‚’æº€ãŸã™ã™ã¹ã¦ã®å‹ãŒåŒä¸€ã®underlying typeã‚’æŒã¤å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãŸã ã—ã€`string`å‹ã¨`[]byte`å‹ã¯ã“ã®ãƒ«ãƒ¼ãƒ«ã®é©ç”¨ä¸Šã¯åŒä¸€è¦–ã—ã¦è‰¯ã„ã“ã¨ã«ãªã£ã¦ã„ã¾ã™ã€‚

ã‚ˆã£ã¦ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã›ã‚“ã€‚
```go
type Constraint interface {
	[10]int | [11]int // ã©ã¡ã‚‰ã‚‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ãŒä½œã‚Œã‚‹ãŒã€underlying typeãŒç•°ãªã‚‹
}

func f[T Constraint]() {
	var t T
	_ = t[:] // ã“ã®ã‚ˆã†ãªã‚¹ãƒ©ã‚¤ã‚¹å¼ã¯ç„¡åŠ¹
}
```
https://go.dev/play/p/y0ZsHgjBtre

:::message
è¨€èªä»•æ§˜ä¸Šã®æ ¹æ‹ ã¯æ¬¡ã®ç®‡æ‰€ã«ã‚ã‚Šã¾ã™ã€‚
https://go.dev/ref/spec#Slice_expressions

> If the operand type is a type parameter, unless its type set contains string types, all types in the type set must have the same underlying type, and the slice expression must be valid for an operand of that type. If the type set contains string types it may also contain byte slices with underlying type []byte. In this case, the slice expression must be valid for an operand of string type.
:::



# æœ€å¾Œã«

ã“ã®è¨˜äº‹ã‚’ã‹ãã«ã‚ãŸã‚Š[#gospecreading](https://gospecreading.connpass.com/)ã‹ã‚‰å¾—ã‚‰ã‚ŒãŸç†è§£ãŒæœ¬è³ªçš„ã§ã—ãŸã€‚ã„ã¤ã‚‚ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚