---
title: "【ネタ】Go言語のbasic interfaceを非可算interface(uncountable interfaces)と呼ぶとかっこいい"
emoji: "👻"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: [Go, 集合論]
published: false
---

# モチベーション

Go1.18のジェネリクス導入に伴い、interface型として定義できる型の範囲が広がりました。

unionsが導入されたからです。

```go
type C interface {
	~int | ~string // unions
}
```

:::message
unionsについて詳しくは[Go言語のジェネリクス入門(1)](https://zenn.dev/nobishii/articles/type_param_intro#unions)を参照してください。
:::

Go言語に関する記事を書いていると、Go1.17以前のinterface型、つまり「unionsを含まないinterface型」だけを指すことばを使いたくなることがしばしばあります。

しかし、言語仕様書にはそのようなinterfaceを表す用語はきちんと定義されていません。

:::message
[Basic Interfaces](https://go.dev/ref/spec#basic_interfaces)という用語は存在するのですが、これは従来からある埋め込みインタフェースを含まないので、ほしいことばよりも少し範囲が狭すぎるのです。
:::

可能な呼び方としては次のようなものが考えられるのですが、どれもいまいちエレガントさに欠けています。

- Go1.17以前のインタフェース
- ジェネリクス以前のインタフェース
- unionsを含まないインタフェース
- ふつうのインタフェース
- 型制約以外で使えるインタフェース

もっとシンプルで本質を捉えた用語を発明できないものでしょうか？

# アプローチ

Go1.18以降のインタフェースは、型集合（型セット）を定めるものとして定義されています。

:::message
型集合（型セット）については[Go の "Type Sets" proposal を読む](https://zenn.dev/nobishii/articles/99a2b55e2d3e50)の後半を参照してください。
:::

インタフェース=集合なのですから、インタフェースの性質をカテゴライズするために「集合」としての性質を使おうと考えるのは自然なことです。

この記事では、次の数学的命題(予想)を提示し、その導出を行います。

:::message
証明というほど厳密に書く力量がないので、インフォーマルな証明という意味で「導出」と書いています
:::

**命題(予想)**

- interface型`I`がunionsを含まないならば、`I`の型セットは[非可算無限集合](https://ja.wikipedia.org/wiki/%E9%9D%9E%E5%8F%AF%E7%AE%97%E9%9B%86%E5%90%88)である
- interface型`I`の型セットが[非可算無限集合](https://ja.wikipedia.org/wiki/%E9%9D%9E%E5%8F%AF%E7%AE%97%E9%9B%86%E5%90%88)であるならば、`I`はunionsを含まない

つまり、unionsを含まないインタフェースであることと、型セットが[非可算無限集合](https://ja.wikipedia.org/wiki/%E9%9D%9E%E5%8F%AF%E7%AE%97%E9%9B%86%E5%90%88)であるインタフェースであることとは同値であると予想します。

そして、この予想に基づき、unionsを含まないインタフェースを「非可算インタフェース(uncountable interfaces)」と呼ぶことが自然である、と主張します。

:::message
もちろん反対語は可算インタフェース(countable interfaces)です。
:::

:::message
実際にこの用語をつかうのはやめたほうがよいとおもいます。
:::

# 道筋

次の命題ツリーを導出していきます。

- unionsを含まないインタフェース型の型集合は非可算無限集合である
    - `any`の型集合は非可算無限集合である
        - あらゆるstruct型からなる集合は非可算無限集合である
- unionsを含むインタフェース型の型集合はたかだか可算無限集合である
    - `~int`は可算無限集合である

# 導出

厳密な証明を書く力量がないので多分この道筋で正当化できるだろうと思っている議論を「導出」として書きます。お願いが2つあります:

- 数学的な誤り(がんばっても数学的に正当化できない議論）を見つけた方は教えていただけると嬉しいです
  - 正当化できると思う、という情報ももちろんうれしいです
- そうでない読者は真に受けすぎないようにしてください

**記号**

- `T`を型とするとき、$\rm{typeset}(T)$で`T`の型集合を表します
- `T`を$\rm{typeset}(T)$と同一視して書いてしまうこともあります

## あらゆるstruct型からなる集合は非可算無限集合である

`int`から出発して`type MyInt int`, `type MyMyInt MyInt`, ...と続けていくことで作れる型全体の集合は可算無限集合です。この集合を`int`系列と呼ぶことにします。
ここで次のように定義できるstruct型をかんがえます:

```go
type struct {
    int
    MyInt
    // MyMyInt をうめこまない
    // MyMyMyInt をうめこまない
    MyMyMyMyInt
    // ...
}
```

つまり、`int`系列に属するdefined typeの列のそれぞれについて、埋め込んだり埋め込まなかったりを独立に選択することで得られるstruct型の集合$S$を考えます。

これはあきらかに`int`系列の[冪集合](https://ja.wikipedia.org/wiki/%E5%86%AA%E9%9B%86%E5%90%88)と一対一に対応します。

[可算無限集合の冪集合は非可算無限集合](https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB%E3%81%AE%E5%AE%9A%E7%90%86)なので、集合$S$は非可算無限集合です。

あらゆるstruct型からなる集合はあきらかに$S$を含むので、非可算無限集合になります。これが示したいことでした。

## `any`の型集合は非可算無限集合である

`any`は前節の集合Sを含むので明らかです。

## unionsを含まないinterface型は非可算無限集合である

unionsを含まないinterface型`I`を任意にとります。

`I`はメソッドの有限集合で特徴づけられ、そのメソッドをすべて実装する型により実装されます。

集合Sの元s(これは型です)に対して`type X s`とし、`X`に対して`I`のメソッド集合のすべてのメソッドを実装することができます。
この`s`に`X`を対応させる写像$f$を使えば、$f$は明らかに単射であり像$f(S)$の元はすべて$\rm{typeset}(I)$の元になります。

よって$\rm{typeset}(I)$は非可算無限集合$f(S)$を含むので非可算無限集合です。これが示したいことでした。

## `~int`は可算無限集合である

`~int`は、`int`をunderlying typeにもつすべての型からなる集合です。

:::message
詳しくは[Go言語のジェネリクス入門(1)](https://zenn.dev/nobishii/articles/type_param_intro#~%E3%81%A8underlying-type)を参照してください。
:::

これは無限集合なのですが、可算無限集合であることを示したいです。

`~int`に属する型`X`は、次のような系列で定義される型です。

```go
type X0 = int
type X1 X0
type X2 X1
type X3 X2
// ...
type X X?
```

ここで、`int`型を空の数列$\{\}$で表します。
また、`~int`に属するある型`X`が有限長の自然数列全体の集合$\mathbb{N}^{\ast}$の要素で表されているとき、次のように定めます。

`type Y X`として新たに定義される型は、型名`Y`を文字列として適当なエンコーディング$E$により自然数で表した$n$を使って、`X`を表す自然数列の最後に$n$を追加して得られる数列で表されるものとします。

このルールを使うと、`int`から型定義を繰り返して作れるあらゆる型は有限長自然数列全体の集合$\mathbb{N}^{\ast}$の元にマッピングできます。(単射で写せます)

一方、この集合$\mathbb{N}^{\ast}$は可算無限集合であることが知られています。

:::message
[こちら](https://www.kurims.kyoto-u.ac.jp/~terui/cs2020.pdf)の命題1.12などを参照してください。
:::

`~int`の濃度は$\mathbb{N}^{\ast}$を超えないため、`~int`が可算無限集合であることがわかりました。


## unionsを含むインタフェース型の型集合は高々可算無限集合である

つまり、非可算無限集合ではないことを示します。

unionsを含むインタフェースを次の選言標準形に変形できます。つまり、unionsはかならず1行しかないものと仮定して良いです。

```go
interface {
    X | ~Y | ...
    Method()
    Method()
}
```

unionsの各要素`X_i`または`~X_i`について考えます。

`~`がついてない要素の型集合は明らかに有限集合です。
`~`がついている要素の型集合は前節の議論により可算無限集合です。

unions全体の型集合はこれらの有限個の集合の和集合なので、高々可算無限集合です。つまり非可算無限集合ではありません。

これにメソッド定義を追加して得られるのが最初に書いたインタフェースで、これの型集合はunionsの型集合の部分集合です。
よって問題のインタフェースの型集合も高々可算無限集合です。

:::message
unionsの選言標準形への変形については[Type Sets Proposalを読む(2)](https://zenn.dev/nobishii/articles/type_set_proposal_2#unions%E3%82%92%E6%A8%99%E6%BA%96%E5%BD%A2%E3%81%AB%E5%A4%89%E5%BD%A2%E3%81%99%E3%82%8B)に詳しく書きました。
:::


# 結論

以上により、

- unionsを含まないインタフェース型の型集合は非可算無限集合である
- unionsを含むインタフェース型の型集合はたかだか可算無限集合である

の両方を示すことができました。つまりインタフェースの型集合が非可算集合(uncountable set)であることと、unionsを含まないこととは同値です。

この命題を踏まえると、

-「unionsを含まないインタフェース」を非可算インタフェース(uncountable interfaces)
-「unionsを含むインタフェース」を可算インタフェース(countable interfaces)

と呼んでも良いかもしれません（強弁）。

:::message
実際にこの用語をつかうのはやめたほうがよいとおもいます。
:::